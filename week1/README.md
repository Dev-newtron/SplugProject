## 7장 포인터

1. 포인터

   메모리: 각 바이트 별로 주소가 붙여진 1차원 배열

   할당 받은 메모리 공간은 변수 이름으로 접근

2. 포인터와 포인터 변수

   포인터: **주소를 다루기 위한** 자료형

   포인터 변수 : 값으로 메모리 주소를 갖는 변수

3. 주소 연산자

   & : 메모리에 할당된 변수의 **주소값을 알려주는** 연산자

4. 포인터 변수와 주소 연산자

   강의 교안에 있는 사용 예제를 잘 보고 어떤 경우에 에러가 나고, 어떤 경우에 실행 가능한지 알면 좋음

5. 역참조 연산자

   포인터가 가리키는 **메모리 공간에 접근**하기 위한 연산자

   포인터는 자료형이다. `int` 자료형인 변수를 어디선가 쓸 때에는 사용하지 않는 것 처럼 `*`도 마찬가지로 자료형인데, 역참조 연산자에 붙은 `*` 는 자료형이 아닌 **연산자**이므로 헷갈리지 말자.

   간단하게 주소를 이용해서 값을 알 수 있는 연산자이다. 해당 연산자가 적용되는 변수에 주소가 있으면 변수에 들어있는 주소를 통해서 해당 주소의 값을 알 수 있다. 

6. 포인터 변수의 크기

   시스템에 따라 상이하지만, 포인터 변수가 가리키는 형과 관계없이 크기가 동일.

   주소를 담는 변수이기 때문에 자료형은 무관하다.

   `sizeof`  연산자로 계산

7. void 포인터 변수

8. void 포인터 변수

   형이 없는 포인터

   포인터는 자동 형 변환이 안된다.

   포인터 변수를 사용할 때는 적절한 형 변환이 필요하다.

9. 포인터의 포인터 변수

   포인터를 가리키는 포인터 변수. 이중 포인터.

   예제 프로그램을 잘 읽고 이해할 것.

10. 포인터 연산

    p, q가 각각 포인터 변수라면, p + i, p - i 가 표현하는 것은 p로부터 i번째 앞 또는 뒤 원소.

    `p - q` : p와 q 사이의 원소 개수

    배열을 생각해보자. 메모리는 1차원 배열이다.

11. 포인터와 함수

    인자 전달 방법: 값에 의한 호출

    원본에 접근: 주소에 의한 호출

12. 값에 의한 호출

13. 주소에 의한 호출

14. 포인터와 배열

    예제를 잘 살펴보면 이해가 될 것. 이 부분에서 문제가 많이 나오니까 꼭 잘 읽고 이해 해야함

15. 배열과 함수

    배열을 매개변수로 갖는 함수

    **배열 매개변수는 포인터**

16. 문자열과 포인터

    문자 배열과 문자열 포인터 차이

17. 동적 메모리 할당

    효울적인 메모리 사용이 가능

    필요할 때 만들어서 쓰고 필요없으면 해제

18. 포인터 배열

    포인터를 원소로 갖는 배열

19. main() 함수의 인자

20. 형 한정자

    const 

    restrict

21. const

    초기화될 수는 있지만, 그 후에 수정될 수 없음

    

    `const int *p = &a`에서 가장 중요한 건, p에 다른 주소를 배정할 수 있지만, *p에 값을 배정할 수는 없음. -> 포인터가 가지는 성격과 `const `의 성격을 보면 포인트는 주소값을 가지고, `const` 해당 변수의 수정이 불가능하다는 점이다. 지금 이 표현은 p에 a의 주소를 주었고, const int이기 때문에, p가 가지는 주소에 들어있는 값을 바꿀 수 없는 거지, p가 가지는 주소를 바꿀 수 없는게 아니다.

    

    **상수 포인터**

    ```c
    int a;
    int * const p = &a;
    ```

    여기서도 이해할 것 이 있는데, 표현식을 보면 int * 형인 const p이다. 즉 p에 할당되는 값은 수정이 불가능 하지만 *p, 즉 p가 가지는 주소에 들어있는 값에는 가능하다고 표현되고 있다. 

    

    ```c
    const int a = 7;
    const int * const p = &a;
    ```

    위의 두 내용을 합친 표현이다.

    

22. restrict

    포인터 변수에 적용되며, 현재 포인트 되는 객체는 다른 포인터에 의해서 포인트 안 됨을 명시하기 위해 사용한다.

23. 함수 포인터

24. qsort()

## 8장 사용자 정의형

1. 사용자 정의형

   기본 자료형 이외에 사용자가 직접 정의하는 데이터형

   	- 배열
   	- 구조체
   	- 공용체
   	- 열거형

2. 구조체

   서로 다른 형의 변수들을 하나로 묶어주는 방법을 제공

   ```c
   struct student {
     char name[10];
     int grade;
   }
   ```

   

   이 표현은 변수를 선언한 것이 아니라 `struct name` 형을 선언한 것.

   

3. 구조체 변수 선언

4. 구조체 멤버 접근 연산자

5. 다양한 구조체 변수 선언

6. typedef

   위에서 얘기했듯이, struct name 은 자료형이므로 이 자료형을 가지는 변수를 선언하려면

   ```c
   struct student st1;
   ```

   이렇게 표현해야 한다. 

   계속해서 이런 방식으로 선언하기에는 변수명이 길 수 도 있기 때문에, typedef를 사용한다.

   ```c
   typedef struct student {
     char name[10];
     int grade;
   } student;
   student st1;
   ```

7. 구조체의 초기화

   멤버 순서대로 초기화가 된다.

   *c99*

   ​	c99 이후부터는 `.` 연산자를 이용해서 멤버를 지정하고 초기화할 수 있다. 

8. 복합 리터럴

9. 구조체 멤버

10. 구조체 포인터

    ```c
    struct student *st1;
    strcpy((*st1).name, 'name');
    
    ```

    그냥 하나만 생각하자. 구조체라는 자료형에 포인터가 붙은 표현이다.

11. 멤버 접근 연산자

    구조체 포인터를 통해 멤버를 접근할 때 사용.

    ```c
    strcpy(st1 -> name, 'name');
    ```

    

12. 구조체 배열

13. 구조체와 함수

14. 공용체

    각 멤버들이 같은 기억장소를 공유함

    ```c
    union short_or_float {
      short s;
      float f;
    };
    ```

    가장 큰 자료형의 크기 만큼 할당.

15. 공용체 선언

16. 공용체 변수 선언

17. 구조체와 공용체

18. 열거형

    ```c
    enum day {SUN, MON};
    ```

    왜 쓰는지에 대한 예시가 있으면 이해가 될 것.

19. 열거형 변수

## 